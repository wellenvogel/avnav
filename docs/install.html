<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Avnav Installation</title>
    <link href="styles.css" rel="stylesheet" type="text/css">
  </head>
  <body data-order="300">
    <h1 class="western">AvNav Installation</h1>
    <div class="toc"> </div>
    <h2>Software Versionen</h2>
    <p>Eine Beschreibung der Versionen und Links zu den Downloads finden sich im
      <a href="release.html">Release Dokument</a>.</p>
    <p>Für Eilige ist hier der Link zum <a href="https://www.free-x.de/raspbian/bullseye">aktuellen
        Image</a>, zu den <a href="../downloads/daily">Entwickler-Versionen</a>
      und zu den <a href="../downloads/release">Release-Downloads</a>.</p>
    <p>Um den Start zu vereinfachen, gibt es fertige Images für den Raspberry
      Pi. Ab Version 20220421 unterstützen die Images sowohl den sogenannten
      "headless" Betrieb - d.h. es ist weder Tastatur noch Monitor am Pi
      angeschlossen als auch einen Betrieb mit einem angeschlossener (Touch-)
      Bildschirm (gerne auch optional Tastatur und Maus).</p>
    <p>AvNav ist von der Bedienung für Touch Geräte optimiert - aber man kann es
      natürlich auch mit Bildschirm, Tastatur und Maus bedienen.</p>
    <p>Wie man die Images nutzt, hängt also vom Anwendungsfall ab. Im "headless"
      Betrieb wird der Raspberry nur als Server eingesetzt, die Anzeige erfolgt
      dann z.B. auf Mobilgeräten. Für diesen Fall reicht ein Raspberry Pi 3B(+).
      Wenn ein Monitor und Peripherie wie Tastatur und Maus direkt an den
      Raspberry angeschlossen werden, sollte man einen Pi4 mit mindestens 2GB
      Speicher wählen. </p>
    <p>Wenn man ein komplettes Desktop System mit vielen weiteren Anwendungen
      haben möchte, kann die <a href="#openplotter">OpenPlotter</a>-Variante
      eine gute Basis sein. Dafür empfiehlt sich ein Pi4 mit 4GB Speicher. Auch
      2GB Arbeitsspeicher wird ausreichen - dann bleibt aber nicht viel Raum für
      zukünftige Anforderungen. </p>
    <p>Die früher vorhandenen speziellen AvNav Touch images werden leider nicht
      mehr weiter gepflegt.</p>
    <h2><a name="Headless"></a>AvNav Images(vormals HeadlessImages)</h2>
    <p>Diese Images werden von <a href="https://www.segeln-forum.de/user/27970-blacksea/">BlackSea</a>
      gepflegt (vielen Dank...). Eine Beschreibung findet sich auf <a href="https://github.com/free-x/avnav/wiki">seiner
        Webseite</a>.</p>
    <p>Unter Windows/Linux/OSx lädt man das Image von <a href="https://www.free-x.de/raspbian/bullseye">free-x</a>
      herunter und transferiert es wie unter <a href="http://www.raspberrypi.org/downloads">http://www.raspberrypi.org/downloads</a>
      (raw images) beschrieben auf eine SD Karte. </p>
    <p>Diese Images enthalten </p>
    <ul>
      <li>avnav</li>
      <li><a href="https://github.com/wellenvogel/avnav-update-plugin">avnav-update-plugin</a></li>
      <li><a href="hints/ocharts.html">avnav-ocharts-plugin</a></li>
      <li><a href="https://github.com/wellenvogel/avnav-mapproxy-plugin">avnav-mapproxy-plugin</a></li>
      <li><a href="https://github.com/wellenvogel/avnav-history-plugin">avnav-history-plugin</a></li>
      <li><a href="hints/CanboatAndSignalk.html">SignalK</a></li>
      <li><a href="hints/CanboatAndSignalk.html">Canboat</a></li>
      <li>Support for <a href="https://www.gedad.de/projekte/projekte-f%C3%BCr-privat/gedad-marine-control-server/">MCS</a></li>
      <li>optional einen X-Server mit openbox und firefox im Kiosk Modus</li>
      <li>Unterstützung für verschiedene <a href="#configHATS">HATs</a></li>
    </ul>
    Die Images sind so vorkonfiguriert, dass NMEA0183-Daten von allen Interfaces
    zu AvNav und von dort zu <a href="hints/CanboatAndSignalk.html">SignalK</a>
    geleitet werden. AvNav holt sich zusätzlich alle Daten von SignalK und kann
    diese anzeigen. Für Details zur SignalK Integration siehe die <a href="hints/CanboatAndSignalk.html#SignalK">Beschreibung</a>.<br>
    NMEA2000-Daten laufen über Canboat zu SignalK und zu AvNav.<br>
    Für Details zu canboat siehe <a href="hints/CanboatAndSignalk.html">CanBoatAndSignalK</a>.
    <h3><a name="preparation"></a>Image Vorbereitung</h3>
    <p>neu ab Version "20210322", erweitert ab Version "20220421"</p>
    <p>Bevor die fertig vorbereitete SD-Karte im Raspberry verwendet wird,
      sollte man einige Einstellungen anpassen. Das gilt vor allem für
      Passworte:<br>
      Die Images haben eine Konfigurationsdatei "avnav.conf". Sie findet sich in
      der ersten Partition der SD-Karte (Boot-Partition). Diese Datei kann mit
      einem Texteditor angepasst werden.<br>
      Dort kann auch eingestellt werden, ob ein lokaler Bildschirm genutzt
      werden soll ("Touch Variante")</p>
    <p>Einfacher geht es mit einer kleinen Web-Oberfläche <a href="../configGen/index.html">hier</a>.
    </p>
    <a href="../configGen/index.html"><img src="ConfigImagesUi.png" class="image"></a>
    <p>Die Bedeutung der Felder:</p>
    <table border="1" width="100%">
      <tbody>
        <tr>
          <td>Name</td>
          <td>Default</td>
          <td>Beschreibung</td>
        </tr>
        <tr>
          <td style="width: 187px;">Wifi SSID</td>
          <td style="margin-left: 112px; width: 229px;">avnav</td>
          <td style="margin-left: 127px;">Der Name des WLAN-Netzwerks, das der
            Raspberry erzeugen soll. Die Images sind so vorbereitet, dass man
            durch Einstecken von WLAN-Adaptern auch weitere Netzwerke erzeugen
            kann. Daher wird eine einstellige Nummer an den Namen angefügt.</td>
        </tr>
        <tr>
          <td>Wifi Password</td>
          <td>avnav-secret</td>
          <td>Das Passwort für das WLAN-Netzwerk. Das sollte in jedem Falle
            geändert werden. Jeder, der sich mit dem WLAN verbinden kann, kann
            damit auch die Navigation beeinflussen!</td>
        </tr>
        <tr>
          <td>User pi password</td>
          <td>raspberry</td>
          <td>Das ist das Passwort für den Nutzer "pi". Dieser Standard- User
            wird genutzt, wenn man sich per SSH verbindet oder wenn man direkt
            per Monitor und Tastatur auf den Raspberry zugreift. Das Passwort
            für den User "pi" sollte ebenfalls unbedingt geändert werden.</td>
        </tr>
        <tr>
          <td><a name="configBOARDS"></a>Base Board</td>
          <td>None</td>
          <td>Hier kann man aus unterstützten Basis-Platinen wählen.<br>
            <ul>
              <li><b>MCS:</b> Wenn diese Optoin aktiviert ist, wird beim
                nächsten Bootvorgang die notwendige Software für den <a href="https://www.gedad.de/projekte/projekte-f%C3%BCr-privat/gedad-marine-control-server/">Marine
                  Control Server von GeDad</a> aktiviert. Die Änderung der
                Einstellung führt dann zu einem automatischen Reboot, wenn der
                Raspberry das erste mal mit dieser Einstellung startet.</li>
              <li><b>OBPPLOTTERV3:</b> Hiermit werden die Einstellungen für den
                <a href="https://open-boat-projects.org/de/10-plotter-raspi-4b">Open
                  Boat Projects Plotter (V3) </a>gesetzt.</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td><a name="configHATS"></a>HAT</td>
          <td>None</td>
          <td>Hier kann man einen unterstützten Pi-HAT auswählen. AvNav wird die
            entsprechenden Einträge für die Overlays in /boot/config.txt machen
            und die CAN Netzwerk-Schnittstellen anlegen.<br>
            <ul>
              <li>WAVESHAREB: <a href="https://www.waveshare.com/wiki/RS485_CAN_HAT_%28B%29">waveshare
                  RS485 CAN HAT (B)</a></li>
              <li>WAVESHAREA8: <a href="https://www.waveshare.com/wiki/RS485_CAN_HAT">waveshare
                  RS485 CAN HAT (8Mhz)<br>
                </a></li>
              <li>WAVESHAREA12: <a href="https://www.waveshare.com/wiki/RS485_CAN_HAT">waveshare
                  RS485 CAN HAT (12 Mhz)</a></li>
              <li>WAVESHARE2CH: <a href="https://www.waveshare.com/wiki/2-CH_CAN_HAT">waveshare
                  2CH CAN HAT</a></li>
              <li>PICANM: <a href="https://cdn.shopify.com/s/files/1/0563/2029/5107/files/pican-m_UGB_20.pdf?v=1619008196">PICAN-M</a></li>
              <li>MCARTHUR: <a href="https://github.com/OpenMarine/MacArthur-HAT">MacArthur
                  HAT</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td><a name="configMODULES"></a>Module RTL8188EU</td>
          <td>aus</td>
          <td>Wenn eingeschaltet, wird der <a href="https://github.com/lwfinger/rtl8188eu/tree/v5.2.2.4">Kernel-Treiber</a>
            für WLAN Adapter mit dem Chipsatz RTL8188EU per <a href="https://manpages.debian.org/unstable/dkms/dkms.8.en.html">DKMS</a>
            eingerichtet.<br>
            Wenn der Kernel des Systems aktualisiert wird (Kommandozeile) wird
            der Treiber neu übersetzt.</td>
        </tr>
        <tr>
          <td><a name="configMODULES"></a>Module RTL8192EU</td>
          <td>aus</td>
          <td>Wenn eingeschaltet, wird der <a href="https://github.com/Mange/rtl8192eu-linux-driver">Kernel
              Treiber</a> für WLAN Adapter mit dem Chipsatz RTL8192EU per <a href="https://manpages.debian.org/unstable/dkms/dkms.8.en.html">DKMS</a>
            eingerichtet.<br>
            Wenn der Kernel des Systems aktualisiert wird (Kommandozeile) wird
            der Treiber neu übersetzt.</td>
        </tr>
        <tr>
          <td>TimeZone</td>
          <td>Europe/Berlin</td>
          <td>Die Zeitzone, die im Image genutzt werden soll.</td>
        </tr>
        <tr>
          <td>WifiCountry</td>
          <td>Germany</td>
          <td>Das Land (muss für den Wifi Adapter aus legalen Gründen gesetzt
            werden)</td>
        </tr>
        <tr>
          <td>InternalWifi as Client</td>
          <td>aus</td>
          <td>Wenn eingeschaltet, wird der interne Wifi Adapter des Pi nicht als
            Access Point definiert, sondern kann sich mit anderen Netzwerken
            verbinden.<br>
            Achtung: Das erfordert eine andere Möglichkeit, um auf den Pi
            zugreifen zu können - siehe [<a href="#access">Verbinden mit dem
              Raspberry</a>].</td>
        </tr>
        <tr>
          <td>KeyboardLayout</td>
          <td>German</td>
          <td>Layout für eine angeschlossene Tastatur (Kommandozeile und X)</td>
        </tr>
        <tr>
          <td>KeyboardType</td>
          <td>Generic 105-key PC(intl.)</td>
          <td>Typ der angeschlossenen Tastatur</td>
        </tr>
        <tr>
          <td>TouchSupport<br>
            (ab 20220421)</td>
          <td>aus</td>
          <td>Wenn eingeschaltet, startet ein X-Server mit einem Firefox Browser
            im Kiosk Modus. Über einen Button in AvNav kann auf einen anderen
            "Bildschirm" gewechselt werden, über den File Manager, Terminal u.ä.
            verfügbar sind.</td>
        </tr>
        <tr>
          <td>Display DPI<br>
            (ab 20220421)</td>
          <td>96</td>
          <td>Nur für den lokalen Bilschirm.<br>
            Die dots/inch für das angeschlossene Display. Beim Klick öffnet sich
            ein kleiner Rechner, in dem die Abmessungen des Bildschirmes in mm
            und Pixel angegeben werden können, daraus wird der DPI Wert
            berechnet.<br>
            Basierend auf diesem Wert, werden einige Anzeige-Elemente skaliert.</td>
        </tr>
        <tr>
          <td>OnScreen KeyboardHeight<br>
            (ab 20220421)</td>
          <td>7</td>
          <td>Die Höhe einer Tastenzeile beim angezeigten OnScreen keyboard. Bei
            korrekter DPI Einstellung sollte dieser Wert ein guter Kompromiss
            sein.<br>
            Wenn man den Wert sehr gross wählt, bleibt u.U. bei angezeigter
            Tastatur nicht mehr genug Bildschirmfläche...</td>
        </tr>
        <tr>
          <td>HideCursor<br>
            (ab 20220421)</td>
          <td>an</td>
          <td>Verbergen des Cursors auf dem lokalen Bildchschirm. Wenn mit einer
            Maus gearbeitet werden soll, muss dieser Schalter auf "aus" gesetzt
            werden.</td>
        </tr>
      </tbody>
    </table>
    <p>Nach dem Eintragen der Werte kann man durch Klick auf den
      "download"-Button die "avnav.conf"-Datei herunterladen. Diese muss in die
      erste Partition der SD-Karte gespeichert werden. Eine eventuell dort
      vorhandene Beispieldatei muss überschrieben werden! Diese Partition muss
      dazu natürlich auf dem Computer sichtbar sein. Unter Windows wird man in
      der Regel nur die erste Partition sehen können. [Eventuell muss man dazu
      nach dem Schreiben des Images die SD-Karte noch einmal enfernen und wieder
      einstecken.] unklarer Satz, warum muss man das?</p>
    <p>Es empfiehlt sich daher, die "avnav.conf"-Date noch einmal an einem
      sicheren Platz zu speichern, um sie ggf. beim Erzeugen einer neuen
      SD-Karte wiederverwenden zu können.</p>
    <p>Nun kann man die SD-Karte in den Raspberry stecken und ihn starten. Der
      erste Boot kann einige Zeit dauern, da das gesamte Dateisystem auf der
      SD-Karte erzeugt werden muss. Je nach den Einstellungen in der
      Konfiguration wird der Raspberry noch ein weiteres Mal neu starten.</p>
    <p>Wenn der Raspberry seine Systemeinrichtung endgültig abgeschlossen hat,
      kann man sich mit ihm verbinden.</p>
    <h3><a name="connecting"></a><a name="access"></a>Verbinden mit dem
      Raspberry Pi</h3>
    <p>Wenn das Image für einen lokalen Bildschirm konfiguriert wurde, kann man
      natürlich direkt mit einem angeschlossenen Bildschirm, ggf. noch Tastatur
      und Maus arbeiten.</p>
    <p>Allerdings sollte man auch diesem Falle eine der hier im Folgenden
      beschriebenen Verbindungen vorbereiten - die braucht man eventuell in
      Fehlersituationen.</p>
    <p>Prinzipiell kann man sich auf mehrere Arten mit dem Raspberry verbinden:</p>
    <ol>
      <li>per Ethernet-Kabel<br>
        Das geht entweder durch Anschluss einen einen Router oder Switch oder
        über eine einfache Verbindung z.B. direkt zu einem Laptop.</li>
      <li>per internem WLAN<br>
        Standardmässig macht der Pi einen Access-point mit der in der
        Konfiguration gewählten SSID auf. Er hängt dort jeweils noch eine nummer
        an (falls man weitere WLAN Adapter anschliesst, kann man auch mehrere
        Access Points erzeugen).</li>
      <li>per USB von einem Android Gerät<br>
        Moderne Android Geräte haben meist eine "USB-Tethering" Funktion, über
        die man das WLAN oder die Mobilfunk-Verbindung per USB weitergeben kann
        (leider meist nur Geräte mit Mobilfunk). <br>
        Über diesen Weg kann man sich auch mit dem Pi verbinden.</li>
      <li>Über ein anderes WLAN.<br>
        Das erfodert aber zunächst eine der anderen Verbindungsmöglichkeiten, da
        man die Zugangsdaten einstellen muss. Ausserdem erfordert es einen
        zusätzlichen WLAN Adapter, der ein eine bestimmte USB Buchse gesteckt
        werden muss (ausser man hat in der Konfiguration "Internal Wifi as
        Client" gewählt).</li>
    </ol>
    <h4>Verbindung per Ethernet Kabel</h4>
    <p>Wenn man den Pi mit einem Router verbindet (z.B. im Heimnetz) dann erhält
      er von diesem eine IP Adresse. Über diese Adresse kann man sich mit dem Pi
      verbinden.<br>
      Da es oft mühsam ist, diese Adresse herauszufinden, macht sich der Pi im
      Netz per <a href="https://en.wikipedia.org/wiki/Multicast_DNS">mDNS</a>
      (Bonjour, Avahi) bekannt.<br>
      Auf diese Weise kann man sich z.B. mit einem Browser einfach zu AvNav
      verbinden:</p>
    <div class="code">http://xxxx.local:8080</div>
    <p>xxx ist dabei der in der Image Konfiguration gewählte Hostname.<br>
      Auch ein Zugang per SSH (unter Windows z.B. per <a href="https://www.chiark.greenend.org.uk/%7Esgtatham/putty/">putty</a>)
      íst auf diese Weise möglich - das Zugangs-Passwort für den Nutzer pi wurde
      ja in der Image Konfiguration gesetzt.</p>
    <p>Falls man sich mit einem Netzwerkkabel direkt z.B. mit einem Laptop
      verbindet, wird der Pi nach einiger Zeit selbständig eine IP Adresse
      aufsetzen. Das kann 1...2 Minuten dauern. Diese gehört zum sogenannten
      Automatic Private IP Addressing Bereich 169.254.x.x. Die meisten Desktop
      Systeme unterstützen das ebenfalls (unter Linux muss man es ggf. explizit
      anschalten). <br>
      Wenn also der Laptop auch auf seinem Ethernet Interface eine solche
      Adresse aufgesetzt hat, sollte eine Verbindung wie beschrieben per
      xxxx.local funktionieren.</p>
    <p>Falls der Zugriff über die xxx.local Adresse nicht funktionieren sollte,
      muss man versuchen, die IP Adresse des Pi zu ermitteln (z.B. in der
      Administration des heimischen Routers).</p>
    <h4><a name="connect-wifi"></a>Verbindung über das eingebaute WLAN</h4>
    <p>Man kann das WLAN-Netzwerk verwenden, das der Raspberry erzeugt hat. Die
      SSID und das Passwort wurden wie oben beschrieben in der Datei
      "avnav.conf" definiert (mit noch einer angehängten Nummer).</p>
    <p> Auch hier steht man vor dem Problem, zunächst die IP-Adresse des Pi
      herauszufinden. Wie schon beim Ethernet Zugang beschrieben, sollte auch
      hier der Zugriff per mDNS funktionieren.</p>
    <div class="code">http://xxx.local</div>
    <p>Falls das nicht funktioniert, kann man es mit den festen IP Adressen
      192.168.30.10, 192.168.40.10, 192.168.50.10, 192.168.60.10 versuchen:</p>
    <div class="code">http://192.168.30.10</div>
    <p><br>
    </p>
    <p>Das sollte die <a href="userdoc/index.html">Hauptseite</a> von AvNav
      laden. Es sollte auch möglich seine, xxxx.local zu benutzen, wenn man sich
      mit dem Raspberry per SSH verbinden will (z.B. <a href="https://www.putty.org/">putty</a>
      unter Windows).<br>
    </p>
    <p>Eine Einschränkung bleibt: Leider funktioniert xxx.local nicht auf
      Android-Geräten. Daher empfehle ich, dort ein Tool zu nutzen, das mDNS
      nutzen kann - einen <a href="https://play.google.com/store/apps/details?id=de.wellenvogel.bonjourbrowser">
        BonjourBrowser </a>. Für IOS gibt es ein&nbsp; <a href="https://play.google.com/store/apps/details?id=de.wellenvogel.bonjourbrowser">vergleichbares
        Tool</a> - auch wenn dort der Eintrag "xxx.local" im Browser
      funktioniert. Man wird seinen Raspberry mit dem AvNav-Image in den
      Browsern unter dem Namen "avnav-server" finden. Typischerweise wird man
      noch einen zweiten Eintrag "avnav" sehen - dahinter verbirgt sich der <a
        href="hints/CanboatAndSignalk.html">SignalK</a>-Server auf dem
      Raspberry.<br>
      Wenn man seinen Raspberry im Bonjour-Browser sehen kann, der Aufruf der
      Seite dann aber fehlschlägt, kann es an einer Besonderheit von Android
      liegen, wenn zusätzlich z.B. per Mobilfunk eine Internet-Verbindung aktiv
      ist. In diesem Falle sollte man mobile Daten zeitweilig abschalten.</p>
    <p>Ab der Version 1.12 unterstützt die Android BonjourBrowser app auch SSH.
      Das AvNav Image (ab 20220421) macht auch seinen SSH Zugang per mDNS
      bekannt. Wenn man unter Android dann noch einen passenden SSh client
      installiert (beispielsweise <a href="https://play.google.com/store/apps/details?id=com.sonelli.juicessh&amp;hl=de&amp;gl=US">JuiceSSH</a>)
      kann man sich auf diese Weise auch per SSH mit dem Pi verbinden. Das ist
      für ein normales Arbeiten meist nicht so komfortabel - aber für den
      Notfall kann man so ein paar Kommandos eingeben.</p>
    Wenn man sich per SSH verbindet, ist der Nutzername "pi". Das
    Nutzer-Passwort wurde in der Datei "avnav.conf" (hoffentlich) gesetzt. .<br>
    <p> Wenn das in der Konfiguration gesetzte Passwort nicht funktioniert, kann
      man noch einmal das Default-Passwort versuchen. Es lautet "raspberry".
      Eventuell wurde die avnav.conf zuvor nicht korrekt gespeichert.<br>
      Eine Root-Shell kann man mit sudo -i erhalten.</p>
    <h4><a name="connect-usb"></a>Verbindung von Android über USB</h4>
    <p>Dazu benötigt man ein Android Gerät, das USB Tethering unterstützt (meist
      bei den Verbindungseinstellungen). Nachdem man das Gerät per USB mit dem
      Pi verbunden hat, muss man das USB Tethering einschalten (wird meist
      automatisch wieder ausgeschaltet, wenn man die Verbindung trennt).<br>
      Neben der Möglichkeit, den Pi so mit dem Internet zu verbinden, kann man
      auch auf den Pi mit dem Browser oder per SSH zugreifen. Da auch wieder die
      Ermittlung der IP Adresse erfolgen muss, empfehle ich wieder die <a href="https://play.google.com/store/apps/details?id=de.wellenvogel.bonjourbrowser">Bonjour
        Browser App</a> zu installieren - siehe unter <a href="#connect-wifi">WLAN</a>.
      Für SSH Zugriffe ebenfalls wieder <a href="https://play.google.com/store/apps/details?id=com.sonelli.juicessh&amp;hl=de&amp;gl=US">JuiceSSH</a>.</p>
    <p>Über diesen Weg kann man auch auf den Pi zugreifen, falls z.B. das WLAN
      nicht funktioniert. Im BonjourBrowser wird man 2 http: Adressen finden
      (Port 8080 für AvNav und Port 3000 für SignalK). Dazu (ab 20220421) noch
      einen SSH Zugang.</p>
    <h4><a name="connect-clientwifi"></a>Verbindung über ein anderes WLAN</h4>
    <p>Wenn man wie unten beschrieben eine WLAN Verbindung zu einem anderen
      Netzwerk eingerichtet hat (erfordert einen WLAN Stick oder Umschaltung des
      internen WLANs auf Client), kann man den Zugriff auf den Pi über dieses
      Netzwerk freigeben ("external access" beim Aufsetzen).</p>
    <p>Das sollte man aber nur in einem geschützten Netzwerk tun (z.B. das Netz
      eines eigenen LTE Routers). <b>Auf keinen Fall sollte man das in einem
        öffentlichen WLAN erlauben - der Zugriff ist nicht geschützt und
        prinzipiell kann jeder aus dem Netz auf den Pi zugreifen</b>.</p>
    <p>Wenn man mit dem client Netzwerk verbunden ist, kann man wieder wie unter
      <a href="#connect-wifi">WLAN</a> beschrieben auf den Pi zugreifen.</p>
    <h3>Pi mit dem Internet verbinden</h3>
    <p>Für einige Funktionen (z.B. update von Software) benötigt der Pi eine
      Internet Verbindung. Diese wird natürlich nicht für die grundlegenden
      Navigationsfunktionen benötigt.</p>
    <p>Vor der Image Version 20220421 ist dabei zu beachten, das der Pi nicht
      automatisch seine Zeit einstellt, wenn kein GPS angeschlossen ist. Das
      kann bei vielen Internet Zugriffen zu Problemen führen. <br>
      Ab der Version 20220421 synchronisiert der Pi nach einer Wartezeit
      automatisch seine Zeit mit dem Netz (ntp).</p>
    <p>Für die Verbindung zum Internet gibt es die folgenden Möglichkeiten:</p>
    <ol>
      <li>Ethernet Verbindung zu einem Router</li>
      <li>Verbindung über ein anderes WLAN</li>
      <li>Verbindung über ein per USB angeschlossenes Android Gerät</li>
    </ol>
    <p>Der Pi stellt seine Internet-Verbindung grundsätzlich über sein eigenes
      WLAN auch verbundenen Geräten zur Verfügung.</p>
    <h4>Verbindung über Ethernet Kabel</h4>
    <p>Hier wird der Pi über ein Ethernet Kabel an einen Router angeschlossen.<br>
      Dazu ist auf dem Pi nichts weiter einzurichten, das sollte automatisch
      gehen.<br>
      Auf einigen Pi3 kann es vorkommen, das ein Netzwerkkabel was erst nach dem
      boot angeschlossen wird, nicht richtig erkannt wird. In diesem Falle den
      Pi mit angeschlossenem Netzwerk neu starten.</p>
    <h4>Verbindung über ein anderes WLAN</h4>
    <p>Dazu wird ein weiterer WLAN Adapter (USB Adapter) benötigt. Bitte vorher
      die Kompatibilität mit dem Pi prüfen - z.B. <a href="https://elinux.org/RPi_USB_Wi-Fi_Adapters">hier</a>.</p>
    <p>Der Stick muss wie im Bild gesteck sein (auf dem Pi4 die blaue USB Buchse
      an der Platinen-Seite). <br>
      Der interne Name des Netzwerk-Interfaces ist wlan-av1.&nbsp; </p>
    <p></p>
    <p> <img class="fimage" src="raspi3-wlan.jpg"></p>
    <p>Alternativ kann in der Image-Konfiguration "InternalWifi as Client"
      gesetzt werden, damit wird der interne WLAN Adapter für die verbindung zu
      anderen Netzten verfügbar. Dann benötigt man aber einen anderen Zugriff
      zum Verbinden mit dem Pi da er keinen Access Point mehr aufmacht.</p>
    <p>Man kann die Verbindung zu einem WLAN in der <a href="userdoc/wpapage.html">App</a>
      konfigurieren.<br>
      Bei jedem WLAN, mit dem man sich verbindet, kann man auswählen, ob ein
      Zugriff auf den Pi von aussen möglich sein soll ("external access"). Wenn
      das nicht ausgewählt ist, kann über dieses WLAN nicht auf AvNav
      zugegriffen werden. Bitte die <a href="#connect-clientwifi">Hinweise zum
        Zugriff</a> beachten.</p>
    <h4>Verbindung über ein per USB angeschlossenes Android Gerät</h4>
    <p>Wie bereits beim <a href="#connect-usb">Zugriff</a> beschrieben, kann
      man ein Android Gerät mit USB Tethering verbinden. Intern ensteht ein
      Netzwerkinterface usb0.<br>
      Darüber kann der Pi ebenfalls auf das Internet zugreifen.</p>
    <p>Das kann eine einfache Möglichkeit sein, wenn man den Zugriff nur
      temporär braucht und keinen zusätzlichen WLAN Adapter zur Verfügung hat.<br>
      Falls man vorher anders mit dem Internet verbunden war, kann es sein, das
      der Pi die USb Verbindung erst nach einem Neustart wirklich nutzt
      (Achtung: USB Tethering auf dem Android Gerät wieder einschalten, wird
      beim Pi-Neustart normalerweise ausgeschaltet).</p>
    <p><br>
    </p>
    <p> </p>
    <h3>Technische Details<br>
    </h3>
    <p>Der Raspberry wird ein (oder mehrere) WLAN-Netzwerke aufsetzen, eines mit
      dem internen Adapter und weitere mit potentiell gesteckten WLAN-Sticks.
      Diese Netzwerke haben die Adressen:192.168.20.0/24, 192.168.30.0/24,
      192.168.40.0/24, 192.168.50.0/24. Der Raspberry selbst hat dabei jeweils
      die Adresse 192.168.x.10.</p>
    <p>Auf dem Raspberry wird dazu ein DHCP-Server und ein DNS-Server
      eingerichtet (dnsmasqd). </p>
    <p>Wenn der Raspberry über ein Ethernet-Kabel verbunden wird, versucht er
      per DHCP eine Adresse aus dem Netzwerk zu erhalten. Er setzt dann eine
      NAT-Weiterleitung aus seinem WLAN-Netz zum Ethernet auf. So kann z.B. eine
      Internetverbindung aufgebaut werden, während man in das WLAN des Raspberry
      eingewählt ist.</p>
    Für die meisten Aktionen sollte ein Kommandozeilen-Zugang jedoch nicht
    erforderlich sein. Für Updates nutzt man das bereits vorinstallierte <a href="https://github.com/wellenvogel/avnav-update-plugin">Update-Plugin</a>.
    Die Server-Konfiguration kann innerhalb der App auf der <a href="userdoc/statuspage.html">Server/Status</a>-Seite
    vorgenommen werden.
    <h2><a name="Touch"></a>Image mit Bildschirm</h2>
    <p> <span>In früheren Versionen gab es ein eigenes AvNav Touch Image.</span><br>
      Dieses wird jedoch nicht mehr weiter gepflegt.<br>
      Ab der Versiion 20220421 wurde daher der Support für einen angeschlossenen
      Bildschirm (mit dem Schwerpunkt touch) in die AvNav images integriert.</p>
    <p>Wie unter <a href="#preparation">Vorbereitung</a> beschrieben, kann man
      die Unterstützung für einen Bildschirm dort aktivieren.<br>
      Wenn das dort eingeschaltet wurde, startet ein service "avnav-startx".
      Dieser erzeugt einen lokalen X Server, eine Nutzer-Sitzung für den Nutzer
      pi mit <a href="http://openbox.org/wiki/Main_Page">openbox</a> als
      Fenster-Manager und Firefox im Kiosk Mode.</p>
    <p>Als Bildschirm-Tastatur (On Screen Keyboard) wird <a href="http://manpages.ubuntu.com/manpages/bionic/man1/onboard.1.html">onboard</a>
      verwendet.</p>
    <p>Auf der AvNav Hauptseite (und auf einigen anderen Seiten) wird ein
      "Raspberry" Button angezeigt, mit diesem wechselt man auf einen zweiten
      virtuellen Bildschirm, auf dem man einen Dateimanager, ein Terminal und
      verschiedene weitere Tools findet.<br>
      Das System ist ganz bewusst nicht als ein komplettes Desktop-System
      ausgelegt, um möglichst Resourcen schonend zu arbeiten.</p>
    <p>Da man an die Systemtools nur über den Button in der AvNav app
      herankommt, ist es sinnvoll, sich einen weiteren Zugang zum Pi wie weiter
      oben beschrieben zuzulegen.<br>
      Damit kann man im Fehlerfall auf das System zugreifen.<br>
      Ein Restart der Nutzeroberfläche von der Kommandozeile kann mit</p>
    <div class="code">sudo systemctl restart avnav-startx</div>
    <p>erfolgen.<br>
      Falls Firefox einmal nicht mehr richtig starten möchte, kann man das
      Nutzerprofil entfernen. Das wird beim nächsten Start neu angelegt.<br>
      <b>Achtung</b>: AvNav Einstellungen, die nicht auf dem Server gespeichert
      wurden, gehen dabei verloren.</p>
    <div class="code">sudo systemctl stop avnav-startx<br>rm -rf /home/pi/.mozilla/firefox/avnav<br>sudo systemctl start avnav-startx</div>
    <p>Ab Version 20230614 wird auf dem Hauptbildschirm immer dann, wen AvNav
      nicht (oder nicht komplett) aktiv ist, ein zusätzliches Panel angezeigt.</p>
    <p><img src="xui-ffpanel.png" alt="" class="fimage"><br>
    </p>
    <p>Über diese Panel können einige Navigationsfunktionen in firefox gesteuert
      werden, es kann zum 2. Bildschirm (system) gewechselt werden - und man
      kann die (oben beschriebene) Reset-Funktion für das firefox Nutzerprofil
      ausführen (<img src="viewerimages/SailBoatRed96.png" alt="" class="inlineimage">).</p>
    <p>Damit ist eine Bedienung des Systems auch möglich, wenn einmal AvNav
      nicht komplett startet. Die Reset Funktion findet sich auch auf dem
      System-Bildschirm (allerdings nur für komplette Neu-Installationen).</p>
    <h2 class="western"><a name="Packages"></a>Paket Installation</h2>
    <h3>Repositories</h3>
    Dank Oleg gibt es&nbsp; fertige Paket-Repositories, die man in sein
    Debian-Linux einbinden kann. Das geht auf dem Raspberry Pi - aber auch auf
    jeder anderen Debian-Variante (z.B. Ubuntu). <br>
    Informationen dazu findet man wieder in seiner <a href="https://github.com/free-x/avnav/wiki">Beschreibung</a>.<br>
    <p>Die Paketquellen bindet man wie folgt ein. Das ist nur nötig, wenn man
      nicht das AvNav-Image nutzt.</p>
    <p> Debian Buster (amd64,armhf,arm64)</p>
    <div class="code">wget https://www.free-x.de/debian/oss.boating.gpg.key
sudo apt-key add oss.boating.gpg.key
wget https://www.free-x.de/debian/boating-buster.list
sudo cp boating-buster.list /etc/apt/sources.list.d/</div>
    <p> Debian Bullseye (amd64,armhf,arm64)</p>
    <div class="code">wget -O - https://www.free-x.de/debian/oss.boating.gpg.key | gpg --dearmor | sudo tee /usr/share/keyrings/oss.boating.gpg
echo "deb [signed-by=/usr/share/keyrings/oss.boating.gpg] https://www.free-x.de/debian bullseye main contrib non-free" | sudo tee -a /etc/apt/sources.list.d/boating.list</div>
    <p> Ubuntu Jammy (amd64)</p>
    <div class="code">wget -O - https://www.free-x.de/ubuntu/oss.boating.gpg.key | gpg --dearmor | sudo tee /usr/share/keyrings/oss.boating.gpg
echo "deb [signed-by=/usr/share/keyrings/oss.boating.gpg] https://www.free-x.de/ubuntu jammy main" | sudo tee -a /etc/apt/sources.list.d/boating.list</div>
    <p>Für die Installation auf einem Linux System muss man nach Einbindung der
      Paketquellen die folgenden Schritte ausführen:</p>
    <div class="code">sudo apt update 
sudo apt install avnav </div>
    <br>
    <h3>Startup</h3>
    Danach kann man als beliebiger Nutzer mit dem Kommando<br>
    <div class="code">avnav</div>
    den Server starten.<br>
    Mit <br>
    <div class="code">sudo systemctl enable avnav
sudo systemctl start avnav</div>
    <p> kann man AvNav mit dem Benutzer "avnav" automatisch beim Systemstart
      aktivieren.</p>
    <h3><a name="userservice"></a>User Service</h3>
    <p>Ab 20240520 kann man AvNav als ein <a href="https://wiki.archlinux.org/title/Systemd/User">user
        systemd service</a> für den eigenen Nutzer automatisch starten lassen.
      Um diesen Service zu aktivieren ruft man </p>
    <div class="code">avnavservice enable [port]</div>
    <p>auf. Der Service startet automatisch wenn sich der Nutzer einlogged und
      stoppt, wenn er sich abmeldet. Um den Service bereits beim Systemstart zu
      aktivieren muss man den "linger" mode für den Nutzer setzen:</p>
    <div class="code">loginctl enable-linger</div>
    <p>Für Details siehe die <a href="https://wiki.archlinux.org/title/Systemd/User">systemd
        Dokumentation</a>.</p>
    <p>Um den Status zu prüfen nutzt man</p>
    <div class="code">systemctl --user status avnav</div>
    <p>AvNav nutzt das (default) Datenverzeichnis $HOME/avnav.</p>
    <p>Um den Service wieder zu deaktivieren nutzt man </p>
    <div class="code">avnavservice disable</div>
    <h3>Download</h3>
    Alternativ kann man auch die Debian-Pakete direkt von der Download-Seite
    herunterladen:<br>
    <ul>
      <li><a title="downloads/releases" href="../downloads/release">Releases</a></li>
      <li><a href="../downloads/daily">Tägliche Builds</a></li>
    </ul>
    <p> Nach dem Herunterladen kann man die Pakete auf einem raspberry pi mit<br>
    </p>
    <div class="code">sudo apt install ./avnav_xxxxxxxx_all.deb
</div> installieren.<br>
    <p>Falls man sein raspberry pi System vergleichbar zu unseren Images
      aufsetzen möchte, kann man dazu noch das "avnav-raspi"-Paket installieren.<br>
      Das ändert die Netzwerk-Konfiguration so , wie AvNav das möchte, sorgt
      dafür, das AvNav unter dem Nutzer "pi" startet und aktiviert das
      Einstellen der Systemzeit sowie das Verwalten von WLAN client Netzwerken.</p>
    Ich würde in jedem Fall empfehlen, das <a href="https://github.com/wellenvogel/avnav-update-plugin">AvNav
      Update-Plugin</a> zu installieren - aus dem Paket Repository mit
    <div class="code">sudo apt-get install avnav-update-plugin</div>
    <p>oder mittels Download von&nbsp; <a href="https://github.com/wellenvogel/avnav-update-plugin">GitHub.</a><br>
      <b>Hinweis</b>: Die start/stop Funktionen im Update-Plugin funktionieren
      (noch) nicht mit einem avnav, das als systemd user Service gestartet
      wurde. Das ist aber kein Problem, da man AvNav auch aus der App selbst
      restarten kann.</p>
    <p>Wenn man nicht das "avnav-raspi"-Paket installiert, man aber AvNav mit
      einem anderen Nutzer als "avnav" - also z.B. dem Nutzer pi starten
      möchte,&nbsp; sollte man wie beschrieben den Start als systemd user
      Service nutzen.</p>
    Man kann dann als Nutzer "pi" AvNav einfach von der Kommandozeile starten
    lassen.<br>
    <p>Wenn man avnav als systemweiten Service mit einem anderen NUtzer laufen
      lassen möchte, kann man auch folgende Schritte abarbeiten:</p>
    <div class="code">/usr/lib/systemd/system/avnav.service.d</div>
    anlegen und dort die Datei anvav.conf mit folgendem Inhalt anlegen:
    <div class="code">
#Overrides for the avnav service
[Service]
User=pi
ExecStart=
ExecStart=/usr/bin/avnav -q -b /home/pi/avnav/data -t /usr/lib/avnav/avnav_template.xml -n /etc/default/avnav

[Unit]
After=avnav-check-parts.service
    </div>
    Danach kann man mit den Kommandos
    <div class="code">sudo systemctl daemon-reload<br>sudo systemctl enable avnav<br>sudo systemctl start avnav</div>
    <p>Avnav als Systemdienst starten. Wenn man diese Datei nicht
      anlegt/kopiert, wird AvNav nicht mit den Nutzer "pi", sondern mit dem
      Nutzer "avnav" arbeiten.</p>
      <a name="openplotter"></a><h2>OpenPlotter </h2>
    <p>Für <a href="https://openmarine.net/openplotter">OpenPlotter</a> gibt es
      eine komplette Integration von AvNav (Dank an <a href="https://github.com/e-sailing">e-sailing</a>).
      Im Repository <a href="https://www.free-x.de/deb4op/">https://www.free-x.de/deb4op/</a>
      , das bereits standardmäßig mit OpenPlotter 2 (und 3) kommt, sind die
      notwendigen Pakete bereits vorhanden. Somit kann man sie einfach
      installieren:</p>
    <div class="code">sudo apt update
sudo apt install openplotter-avnav</div>
    <p> </p>
    <p>Seit 2021/03 ist AvNav offiziell in OpenPlotter verfügbar. So sollte nach
      einem Update von OpenPlotter "openplotter-avnav" bereits verfügbar sein.</p>
    <p>Das Paket "avnav-raspi_xxx.deb" sollte man auf OpenPlotter nicht
      installieren, weil es sich nicht mit den Netzwerkeinstellungen von
      OpenPlotter verträgt. Innerhalb der OpenPlotter-AvNav-Konfiguration kann
      man den HTTP-Port für AvNav ändern, wenn es Probleme mit anderen Apps
      geben sollte. Die Defaultwerte sind: :8080 für den Browserzugriff, :8082
      für ocharts.</p>
    <p>Wenn man AvNav mit der OpenPlotter-App installiert, empfängt AvNav alle
      NMEA-Daten von SignalK und sucht nicht selbst nach USB Geräten. Alle
      Geräte-Konfigurationen oder Schnittstellen-Einrichtungen können so direkt
      in OpenPlotter und SignalK vorgenommen werden.</p>
    <h2><a name="Windows"></a>Windows</h2>
    <p> Für Windows gibt es einen Installer (neu ab 20240520). Die aktuelle
      Version zum Download findet man <a href="../downloads/release/latest/avnav-service-latest.exe">hier</a>.
      Dieser Installer erzeugt eine App "avnavservice" die (als default)
      automatisch startet(User autostart). Dieser Service erzeugt eine
      Notifikation (Icon) die bei Klick ein Menü mit den wichtigsten Funktionen
      zeigt. Dieser service enhält noch nicht die eigentliche AvNav software
      (oder die notwendigen Python Pakete). Aber über das Menü können diese
      installiert werden.<br>
      Für eine Deinstallation von avnavservice bitte die Systemsteuerung nutzen.</p>
    <p><img src="windows-notification-1.png" alt=""></p>
    <p><img src="windows-notification-2.png" alt=""></p>
    <p>Das service Menü hat die folgenden Einträge:</p>
    <table border="1" width="100%">
      <tbody>
        <tr>
          <td>Bezeichnung</td>
          <td>Funktion</td>
        </tr>
        <tr>
          <td>Start</td>
          <td>Startet den AvNav Server. Nur aktive, wenn die AvNav software
            installiert wurde und der Server noch nicht läuft. Der Service merkt
            sich ob AvNav gestartet wurde und wird es beim nächsten Stat
            automatisch wieder staerten, wenn nicht zischenzeitlich "Stop"
            aktiviert wurde.</td>
        </tr>
        <tr>
          <td>Stop</td>
          <td>Stoppt den AvNav Server.</td>
        </tr>
        <tr>
          <td>Open</td>
          <td>Öffnet den default Browser mit der URL für den AvNav Server.</td>
        </tr>
        <tr>
          <td>Logs</td>
          <td>Öffnet ein Explorer Fenster im AvNav log Verzeichnis
            (PROFILEDIR/AvNav/logs). Dort gibt es das normale avnav.log und
            zusätzlich die Ausgabe vom startup(service-err.log).<br>
            Um z.B. zur AvNav XML Konfiguration zu gelangen, muss man nur im
            Explorer ein Verzeichnis nach oben navigieren.</td>
        </tr>
        <tr>
          <td>Config</td>
          <td>Erlaubt es, den HTTP Port für AvNav zu setzen(default: 8080).</td>
        </tr>
        <tr>
          <td>Update</td>
          <td>Diser Eintrag ist "Install" wenn die AvNav Software noch nicht
            installiert wurde.<br>
            Ein Installationsdialog wird geöffnet(siehe <a href="#windowsinstall">unten</a>).</td>
        </tr>
        <tr>
          <td>Remove</td>
          <td>Entfernt die installierte AvNav Software (aber alle Nutzerdaten
            unter PROFILEDIR/AvNav bleiben erhalten).<br>
            Vor einer Deinstallation von avnavservice (über
            Systemsteuerung/Software) sollte das genutzt werden - sonst muss man
            später das Verzeichnis PROFILEDIR/AppData/Local/avnav per Hand
            entfernen.</td>
        </tr>
        <tr>
          <td>Exit</td>
          <td>Stoppt AvNav und beendet avnavservice (die Notifikation
            verschwindet). Um den Service erneut zu starten, nutzt man das
            Startmenü.<br>
            Normalerweise kann man den Service laufen lassen. Wenn der AvNav
            Server gestoppt ist, werden kaum Systemresourcen verbraucht. Nur
            nach einer erneuten Installtion von avnavservice muss man diesen
            einmal stoppen und wieder starten.</td>
        </tr>
      </tbody>
    </table>
    <h3><a name="windowsinstall"></a>Installation</h3>
    <p>Nach Klick auf Install/Update wird ein kleiner Dialog angezeigt.</p>
    <p><img src="windows-install-1.png" alt=""></p>
    Die hier eingetragene URL zeigt auf die aktuelle AvNav software. Aber man
    kann hier jede URL eingeben, die auf ein aktuelles AvNav Softwarepaket zeigt
    (zip Datei) - z.B. von den <a href="../downloads/daily">daily</a> oder <a
      href="../downloads/release">release</a> Seiten. <br>
    <p>Nach OK wird ein Installationsfenster angezeigt mit dem Fortschritt.</p>
    <p><img src="windows-install-2.png" alt="" class="fimage image"></p>
    Nachdem man diese Fenster geshlossen hat, kann man den AvNav Server über
    "Start" im Menü wieder starten.<br>
    <h3>Windows Hinweise</h3>
    <p>Der avnavservice erfordert Powershell (&gt;= 5.x) - das sollte auf allen
      modernen Windows Systemen verfügbar sein. Wenn die AvNav Installation auf
      einen Fehler läuft kann es sein, das die neuesten C/C++ Bibliotheken nicht
      installiert sind. Diese kann man von <a href="https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170">Microsoft</a>
      herunter laden. Der direkte Link ist normalerweise <a href="https://aka.ms/vs/17/release/vc_redist.x64.exe">hier</a>.
    </p>
    <p>Dieser neue Windows service ersetzt die alte AvNavNet installation mit
      einer eigenen GUI. Releases ab 20240520 sind nicht mehr kompatibel mit der
      alten Version. Es wird empfohlen, die alte Installation komplett zu
      entfernen, ehe der neue Installer genutzt wird.</p>
    <p>Die Karten-Konvertierung ist nun ohnehin komplett in AvNav integriert und
      kann so genutzt werden wie in der App Dokumentation beschrieben.<br>
      Man kann serielle Geräte, die am Windows System angeschlossen sind, ganz
      normal benutzen(z.B. einen GPS Stick).</p>
    <p>Da der AvNav Server im Hintergrund läuft, kann man ihn zum Beispiel auch
      als NMEA Multiplexer und Logger nutzen.</p>
  </body>
</html>
