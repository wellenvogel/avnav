import java.security.MessageDigest
import java.text.SimpleDateFormat
import org.apache.commons.net.ftp.*
import org.eclipse.jgit.storage.file.FileRepositoryBuilder
import org.eclipse.jgit.lib.Repository
import org.eclipse.jgit.lib.ObjectId
import org.gradle.api.*
buildscript{
    repositories{
        mavenCentral()
    }
    dependencies{
        classpath localGroovy()
        classpath 'com.netflix.nebula:gradle-ospackage-plugin:7.5.0'
        classpath 'commons-net:commons-net:3.3'
        classpath 'org.eclipse.jgit:org.eclipse.jgit:4.6.0.201612231935-r'
        classpath group: 'org.ccil.cowan.tagsoup', name: 'tagsoup', version: '1.2.1'
    }
}

repositories{
    mavenCentral()
}


void checkGitVersion(String version){
    logger.info("checking for git tag $version")
    FileRepositoryBuilder builder=new FileRepositoryBuilder()
    Repository repo=builder.readEnvironment().findGitDir(project.buildDir).setMustExist(true).build()
    ObjectId head=repo.resolve("HEAD")
    logger.info "current git commit=$head.name"
    def tags=repo.getTags()
    def tagCommit=tags.get(version)
    assert tagCommit,"unable to find tag $version"
    ObjectId tagResolved=repo.resolve(tagCommit.getName())
    assert tagResolved.getName() == head.getName(),"found $version ($tagResolved.name) but this is not the current HEAD"
    logger.info "version $version resolves to $tagCommit"
}

if (project.hasProperty("avnavRelease")){
    project.ext.avnavRelease=true
    logger.lifecycle "setting avnavRelease"
}
else {
    project.ext.avnavRelease=false
    def cmdLineTasks=project.gradle.getStartParameter().getTaskNames()
    cmdLineTasks.each { String t ->
        if (t.matches(/.*[rR]elease.*/)) {
            project.ext.avnavRelease = true
            logger.lifecycle "seeting avnavRelease due to task $t"
        }
    }
}
if (! project.hasProperty('packageVersion')){
    SimpleDateFormat f=new SimpleDateFormat('YYYYMMdd')
    project.ext.avnavVersion=f.format(new Date())
}
else{
    project.ext.avnavVersion=project.packageVersion
}

boolean onWindows=false
if (System.properties['os.name'].toLowerCase().contains('windows')) {
    println "running on Windows"
    onWindows = true
}

boolean buildAndroid=false
if (System.getenv("ANDROID_HOME")){
    buildAndroid=true
}
else{
    logger.warn("ANDROID_HOME not set, cannot build android")
}


description="NMEA multiplexer and Browser based navigation"
apply plugin: 'java'

apply plugin: 'nebula.ospackage-base'

task testGit{
    doLast() {
        try {
            checkGitVersion((project.avnavRelease ? "release-" : "") + project.avnavVersion)
        } catch (Error t) {
            if (!project.hasProperty("avnavIgnoreGit")) throw t;
            logger.lifecycle "### ignoring failed GIT check ###"
        }
    }
}

def taskgroup="avnav"
['assembleRelease','assembleDebug','assembleBeta','clean'].each { tt ->
    tasks.create(name:"${tt}Android",type: GradleBuild) {
        group taskgroup
        setDir("android")
        setTasks([tt])
    }
}
clean.dependsOn cleanAndroid
build.dependsOn assembleReleaseAndroid

["debug","release","clean"].each { tt ->
    def vt=tasks.create(name: "${tt}Viewer",type: GradleBuild) { GradleBuild b->
        b.group taskgroup
        b.setDir("viewer")
        b.setTasks([tt])

    }
    if (tt == "clean"){
        clean.dependsOn vt
    }
    else{
        build.dependsOn vt
    }
}

def guiVersionFile=new File(project.buildDir,"avnav_gui_version.py")
def serverVersionFile=new File(project.buildDir,"avnav_server_version.py")


task pkgVersion{
    doLast() {
        ospackage.version = project.avnavVersion
        println "package version $ospackage.version"
        [guiVersionFile, serverVersionFile].each {
            if (!it.getParentFile().isDirectory()) it.getParentFile().mkdirs()
            it.withWriter { wr ->
                wr.println("AVNAV_VERSION=\"$ospackage.version\"")
            }
        }
    }
}

def markerFile=new File(project.buildDir,"__avnav_software_archive__")
task zipMarker{
    doLast{
        if (!markerFile.getParentFile().isDirectory()) markerFile.getParentFile().mkdirs();
        markerFile.withWriter{ wr->
            wr.println(project.avnavVersion)
        }
    }
}

def releaseHtAccess=new File(project.buildDir,"release.htaccess")
def dailyHtAccess=new File(project.buildDir,"daily.htaccess")
def windowsHtAccess=new File(project.buildDir,"windows.htaccess")

def createHtAccess(dest,version){
    File ddir=dest.getParentFile()
    if (! ddir.exists()) ddir.mkdirs()
    File src=new File(project.projectDir,dest.getName())
    if (! src.exists()) throw new Exception("$src not found")
    src.withReader{ rd->
        dest.withWriter{ wr->
            rd.readLines().each { String line ->
                line=line.replace("VERSION",version)
                wr.println(line)
            }    
        }
    }
}

task releaseAccessFile{
    doLast{
        createHtAccess(releaseHtAccess,project.avnavVersion)
    }
}

task dailyAccessFile{
    doLast{
        createHtAccess(dailyHtAccess,project.avnavVersion)
    }
}
task windowsAccessFile{
    doLast{
        createHtAccess(windowsHtAccess,project.avnavVersion)
    }
}

task windowsBuild(type: org.gradle.api.tasks.GradleBuild){
    dir="windows"
    tasks=["release"]
    doFirst{
        assert onWindows,"we cannot run the windowsBuild task as we are not on windows"
    }
}
task noWindowsBuild{
    doLast() {
        println "###unable to build the windows installer as we are not running on windows###"
    }
}
def emptyBase=new File(project.buildDir,"empty")
ospackage {
    //release='3'
    os = LINUX // only applied to RPM
    packageGroup='misc'
    packageName='avnav'
    requires('bluetooth')
    requires('python-bluez')
    requires('python-pyudev')
    requires('python-serial')
    requires('python-gdal')
    requires('python-imaging').or('python-pil')
    requires('python-netifaces')
    requires('python-websocket')
    user='root'
    into ('/usr/lib/avnav') {
        from('viewer/build/release') {
            into 'viewer'
        }
        from('server') {
            include "*.py"
            into "server"
            fileMode 0755
        }
        from('sounds'){
            into "sounds"
            include "*.mp3"
            include "*.txt"
        }
        from('server/handler') {
            include "*.py"
            into "server/handler"
            fileMode 0755
        }
        from('server/plugins'){
            into 'server/plugins'
            fileMode 0644
        }
        from('chartconvert') {
            include "*.py"
            into 'chartconvert'
            fileMode 0755
        }
        from('chartconvert/tiler_tools') {
            include "*html"
            include "*csv"
            into 'chartconvert/tiler_tools'
            fileMode 0644
        }
        from('chartconvert/tiler_tools') {
            include "*.py"
            into 'chartconvert/tiler_tools'
            fileMode 0755
        }
        from('libraries') {
            include 'gpxpy*/**'
            into 'libraries'
        }
        from('linux') {
            include "avnav_template.xml"
        }
        from('linux') {
            include "avnav"
            fileMode 0755
        }
        from('linux') {
            include "avnav_gui*"
            fileMode 0755
            into "gui"
        }
        from(guiVersionFile.getParentFile()){
            into "gui"
            include guiVersionFile.getName()
        }
        from(serverVersionFile.getParentFile()){
            into "server"
            include serverVersionFile.getName()
        }
    }
    into ('/usr/lib/systemd/system'){
        from('linux'){
            include 'avnav.service'
        }
    }
    postInstall file('linux/postinstall')

    link('/usr/bin/avnav','/usr/lib/avnav/avnav')
}


task buildZip(type: Zip){
    //archiveName="avnav.zip"
    archiveVersion=project.avnavVersion
    dependsOn 'releaseViewer',pkgVersion, zipMarker
    group taskgroup
    includeEmptyDirs=false
    with ospackage.delegateCopySpec
    eachFile{ d->
        if (!d.getPath().matches("^usr/lib/avnav.*")) {
            d.exclude()
            return
        }
        d.setPath(d.getPath().replaceAll("^usr/lib/avnav/",""))
    }
    into('usr/lib/avnav/windows') {
        from('windows'){
            include("avnav_server_home.xml")
            rename "avnav_server_home.xml","avnav_server.xml"
            include("downloadAndInstall.ps1")
        }
    }
    into('usr/lib/avnav/test'){
        from('test'){
            include("nmea-20130630-3.log")
        }
    }
    into('usr/lib/avnav'){
        from(markerFile.getParentFile()){
            include markerFile.getName()
        }
    }
}

task raspiDeb(type: GradleBuild){
    group taskgroup
    buildFile="raspi.gradle"
    tasks=['raspiDeb']
}



task releaseRpm(type: Rpm) {
    group taskgroup
    arch = NOARCH
    dependsOn 'releaseViewer',pkgVersion
}

task releaseDeb(type: Deb) {
    group taskgroup
    dependsOn 'releaseViewer',pkgVersion
}

task release{
    group taskgroup
    description "build all avnav release stuff"
    doLast {
        println "all release packages have been build"
    }
    dependsOn testGit, releaseRpm, releaseDeb,raspiDeb
    if (onWindows){
        dependsOn windowsBuild
    }
    else{
        dependsOn noWindowsBuild
    }
    if (buildAndroid){
        dependsOn assembleReleaseAndroid
    }
}
task beta{
    group taskgroup
    description "build all avnav beta stuff"
    doLast {
        println "all beta packages have been build"
    }
    dependsOn releaseRpm, releaseDeb,raspiDeb
    if (onWindows){
        dependsOn windowsBuild
    }
    else{
        dependsOn noWindowsBuild
    }
    if (buildAndroid){
        dependsOn assembleBetaAndroid
    }
}

def md5( obj ) {
    def hash = MessageDigest.getInstance( 'MD5' ).with {
        obj.eachByte( 8192 ) { bfr, num ->
            update bfr, 0, num
        }
        it.digest()
    }
    return new BigInteger( 1, hash ).toString( 16 ).padLeft( 32, '0' )

}
def computeHashes(fileTree){
    def rt=[:]
    fileTree.visit { FileVisitDetails element ->
        if (element.isDirectory()) return
        def name=element.getPath()
        def hash=md5(element.open())
        rt.put(name,hash)
    }
    return rt
}

class UploadTask extends DefaultTask{

    protected createdDirs=[]
    private void checkReply(FTPClient ftp){
        if (! FTPReply.isPositiveCompletion(ftp.getReplyCode())){
            throw new Exception("negative ftp reply: "+ftp.getReplyString())
        }
    }

    protected Hashes=[:]

    private void removeRemoteDir(FTPClient ftpClient, String dirToList) {
        logger.info("delete remote dir $dirToList")
        FTPFile[] subFiles = ftpClient.listFiles(dirToList);
        if (subFiles != null && subFiles.length > 0) {
            for (FTPFile aFile : subFiles) {
                String currentFileName = aFile.getName();
                if (currentFileName.equals(".") || currentFileName.equals("..")) {
                    // skip parent directory and the directory itself
                    continue;
                }
                String filePath = dirToList + "/"+currentFileName
                if (aFile.isDirectory()) {
                    // remove the sub directory
                    removeRemoteDir(ftpClient, filePath);
                } else {
                    // delete the file
                    boolean deleted = ftpClient.deleteFile(filePath);
                }
            }

            // finally, remove the directory itself
            boolean removed = ftpClient.removeDirectory(dirToList);
        }
    }
    /**
     * create a remote dir and change to it
     * @param client
     * @param path
     */
    private void createRemoteDir(FTPClient client,String path){
        if (createdDirs.contains(path)) return
        boolean abs=false
        if (path.startsWith("/")){
            abs=true
            path=path.substring(1)
        }
        def dirs=path.split(/\//)
        def curpath=""
        if (abs){
            boolean res=client.changeWorkingDirectory("/")
            if (! res){
                String wd=client.printWorkingDirectory()
                logger.info("current working dir=$wd")
                if (wd == "/") res=true
            }
            assert res,"unable to change to ftp root dir"
            curpath="/"
        }
        dirs.each{ String dir->

            org.apache.commons.net.ftp.FTPFile [] subFiles=client.listDirectories()
            boolean res=false
            curpath+="$dir/"
            if (subFiles != null && subFiles.contains(dir)){
                logger.info("directory $curpath/$dir already exists")
                res=client.changeWorkingDirectory(dir)
            }
            else{
                client.makeDirectory(dir)
                res=client.changeWorkingDirectory(dir)
            }
            assert res,"unable to change to ftp directory $curpath"
        }
        createdDirs.add(path)
    }

    protected void uploadFile(FTPClient ftp,String dir,File ifile){
        createRemoteDir(ftp,dir)
        ftp.setFileType(FTP.BINARY_FILE_TYPE)
        FileInputStream is=new FileInputStream(ifile)
        logger.lifecycle("uploading $ifile to $dir")
        def targetName=ifile.getName()
        if (getTargetName != null){
            targetName=getTargetName(ifile)
        }
        try {
            ftp.storeFile(targetName, is)
        }catch (Exception e){
            logger.error("Exception while uploading: ",e)
            e.printStackTrace()
            throw e
        }
        logger.lifecycle("upload of $ifile complete")
    }

    protected void writeRemoteHashes(FTPClient ftp,String baseDir,HashMap hashes){
        createRemoteDir(ftp,baseDir)
        ftp.setFileType(FTP.BINARY_FILE_TYPE)
        def os=ftp.storeFileStream(hashFileName)
        os.withPrintWriter { wr ->
            hashes.each { name, md5 ->
                logger.debug("writing remote hash entry name=${name}, hash=${md5}")
                wr.println("${md5} ${name}")
            }
        }
        ftp.completePendingCommand()
    }

    protected Map readRemoteHashes(FTPClient ftp, String baseDir){
        def rt=[:]
        ftp.setFileType(FTP.BINARY_FILE_TYPE)
        def cs=ftp.changeWorkingDirectory(baseDir)
        if ( !cs){
            logger.info("base dir ${baseDir} not found in remote, unable to read hashes")
            return null
        }
        logger.info("trying to read remote hash file ${baseDir}/${hashFileName}")
        def is=ftp.retrieveFileStream(hashFileName)
        if (is == null) {
            logger.info("ftp reply code was ${ftp.getReplyCode()}")
            return null
        }
        is.withReader{ rd->
            rd.readLines().each{ line->
                def nv=line.split(" ",2)
                if (nv.size() < 2){
                    logger.info("invalid line in remote hash: ${line}, ignoring")
                    return
                }
                logger.debug("reading remotze hash, name=${nv[1]}, md5=${nv[0]}")
                rt.put(nv[1],nv[0])
            }
        }
        ftp.completePendingCommand();
        return rt
    }
    def server="www.wellenvogel.net"
    def baseDir="/www/software/avnav/downloads/daily"
    def subDir=project.avnavVersion
    def useHashes=false
    def hashFileName="_hashes"

    File inputFile
    def getTargetName=null
    FileTree inputFiles
    boolean deleteTargetDir=false
    @TaskAction
    public void exec(){
        /*
        project.exec {
            commandLine "ping","$server"
        }
        */
        assert (inputFile!=null || inputFiles!=null),"missing task parameter inputFile(s)"
        assert project.hasProperty("avnavVersion")
        logger.info("uploading to $server")
        def ftp=new FTPClient();
        def user=System.getenv("AVNAV_REPO_USER")
        assert user!=null,"missing environment variable AVNAV_REPO_USER"
        def passwd=System.getenv("AVNAV_REPO_PASSWD")
        assert passwd !=null,"missing environemt variable AVNAV_REPO_PASSWD"
        ftp.connect(server)
        checkReply(ftp)
        ftp.login(user,passwd)
        checkReply(ftp)
        ftp.enterLocalPassiveMode()
        ftp.setBufferSize(1024*1024)
        def dir=baseDir
        def remoteDir=(subDir!=null)?baseDir+"/"+subDir:baseDir
        if (inputFile != null){
            assert inputFile.exists(),"input file $inputFile does not exist"
            if (deleteTargetDir) removeRemoteDir(ftp,remoteDir)
            uploadFile(ftp,remoteDir,inputFile)
        }
        else{
            def skipList=[:]
            def removeList=[:]
            def hasChanges=false
            if (deleteTargetDir) removeRemoteDir(ftp,dir)
            if (useHashes && ! deleteTargetDir){
                logger.info("computing local hashes")
                Hashes=project.computeHashes(inputFiles)
                def remoteHashes=readRemoteHashes(ftp,dir)
                if (remoteHashes == null){
                    hasChanges=true
                    logger.lifecycle("no remote hashes file found, deleting remote dir")
                    removeRemoteDir(ftp,dir)
                }
                else{
                   Hashes.each{ name,md5 ->
                       def remote=remoteHashes.get(name)
                       if (remote != null){
                           if (remote == md5){
                               logger.info("skipping file ${name} due to equal hash")
                               skipList.put(name,true)
                           }
                           else{
                               logger.info("changed hash for ${name}")
                               hasChanges=true
                           }
                       }
                       else{
                           hasChanges=true
                       }
                   }
                   remoteHashes.each { name,md5 ->
                       if (Hashes.get(name) != null) return;
                       logger.info("marking remote file ${name} for deletion")
                       removeList.put(name,true)
                       hasChanges=true
                   }
                   if (hasChanges) ftp.deleteFile(dir+"/"+hashFileName)
                }
            }
            inputFiles.visit {FileVisitDetails element->
                if (!element.isDirectory()) {
                    if (skipList.get(element.getPath())){
                        logger.debug("skipping upload for ${element.getPath()}")
                        return
                    }
                    String dirname = (dir + "/" + element.relativePath.getPathString()).replaceAll('/[^/]*$', '')
                    uploadFile(ftp, dirname, element.getFile())
                }
            }
            removeList.each{ name,flag ->
                String fileName=dir+"/"+name
                logger.info("removing remote file ${fileName}")
                ftp.deleteFile(fileName)
            }
            if (useHashes && hasChanges){
                logger.info("writing remote hashes")
                writeRemoteHashes(ftp,dir,Hashes)
            }


        }
        //checkReply(ftp)
        ftp.disconnect()
    }
}

task uploadDeb(type: UploadTask){
    inputFile=file("$buildDir/distributions/avnav_${project.avnavVersion}_all.deb")
    dependsOn releaseDeb
}
task uploadRaspi(type: UploadTask){
    inputFile=file("$buildDir/distributions/avnav-raspi_${project.avnavVersion}_all.deb")
    dependsOn raspiDeb
}
task uploadZip(type: UploadTask){
    inputFile=file("$buildDir/distributions/avnav-${project.avnavVersion}.zip")
    dependsOn buildZip
}
task uploadRpm(type: UploadTask){
    inputFile=file("$buildDir/distributions/avnav-${project.avnavVersion}.noarch.rpm")
    dependsOn releaseRpm
}
task uploadWindows(type: UploadTask){
    def windowsVersion=project.avnavVersion.replaceAll(/(....)(..)(..)/,'$1-$2-$3').replaceAll(/-0([^-])/,'-$1')
    inputFile=file("windows/build/AvNavSetup-${windowsVersion}-0.exe")
    dependsOn windowsBuild
}
task uploadWindowsNet(type: UploadTask){
    def windowsVersion=project.avnavVersion.replaceAll(/(....)(..)(..)/,'$1-$2-$3').replaceAll(/-0([^-])/,'-$1')
    inputFile=file("windows/build/AvNavNetSetup-${windowsVersion}-0.exe")
    dependsOn windowsBuild
}


task uploadAccess(type: UploadTask){
    dependsOn project.avnavRelease?releaseAccessFile:dailyAccessFile
    inputFile=project.avnavRelease?releaseHtAccess:dailyHtAccess
    subDir=null
    getTargetName={ return ".htaccess"}
}
task uploadAccessWindows(type: UploadTask){
    dependsOn windowsAccessFile
    inputFile=windowsHtAccess
    subDir=null
    getTargetName={ return ".htaccess"}
    baseDir="/www/software/avnav/downloads" 
}

def ks=System.getenv("ANDROID_KEYSTORE")
def sign="-unsigned"
if (ks) sign=""
task uploadAndroidRelease(type: UploadTask){
    inputFile=file("android/build/outputs/apk/release/avnav-release$sign-${avnavVersion}.apk")
    dependsOn assembleReleaseAndroid
}
task uploadAndroidBeta(type: UploadTask){
    inputFile=file("android/build/outputs/apk/beta/avnav-beta$sign-${avnavVersion}.apk")
    dependsOn assembleBetaAndroid
}

task uploadViewer(type: UploadTask){
    useHashes=true
    inputFiles=fileTree(dir:"viewer/build/release")
    inputFiles+=fileTree("viewer/demo",{
        include "demo-osm/**"
    })
    inputFiles+=fileTree("viewer/demo",{
        include "demo-eniro/**"
    })
    inputFiles+=fileTree("viewer/demo",{
        include "demo-bsh/**"
    })
    baseDir="/www/software/avnav/viewern"
    //deleteTargetDir=true
    dependsOn releaseViewer
}

task uploadViewerRelease(type: UploadTask){
    useHashes=true
    inputFiles=fileTree(dir:"viewer/build/release")
    inputFiles+=fileTree("viewer/demo",{
        include "demo-osm/**"
    })
    inputFiles+=fileTree("viewer/demo",{
        include "demo-eniro/**"
    })
    inputFiles+=fileTree("viewer/demo",{
        include "demo-bsh/**"
    })
    baseDir="/www/software/avnav/viewern"
    //deleteTargetDir=true
    dependsOn releaseViewer
}

def docTree=fileTree("docs",{
    exclude "viewerimages"
    include "**/*html"
    include "**/*css"
    include "**/*pdf"
    include "**/*PDF"
    include "**/*json"
})
task addImagesToDoc(type: DefaultTask){
    doFirst(){
        def imageFiles=findImages(docTree)
        imageFiles.each { img->
            logger.info("add image file $img")
            docTree.include(img)
        }
    }
}
task uploadDoc(type: UploadTask){
    inputFiles=docTree
    deleteTargetDir=false
    baseDir="/www/software/avnav/docs"
    useHashes=true
    dependsOn addImagesToDoc
}

task computeDocHashes(type:DefaultTask){
    dependsOn addImagesToDoc
    doFirst(){
        def hashes=computeHashes(docTree)
        hashes.each{ n,v->
            println "${n}=${v}"
        }
    }
}


import groovy.util.XmlSlurper
def findImages(fileTree){
    def result=[]
    fileTree.visit{ FileVisitDetails element ->
          if (! element.getFile().isFile()) return;
          if (! element.getName().matches('.*html$')) return;  
          def tagsoupParser = new org.ccil.cowan.tagsoup.Parser()
          def page = new XmlSlurper(tagsoupParser).parse(element.getFile())
          page.'**'.findAll().each{ node->
            if (node.name() == "img" ){
                if (node.@src.toString().startsWith("http")) return;
                def imgFile=RelativePath.parse(true,node.@src.toString())
                def completePath=element.getRelativePath().getParent().append(imgFile)
                def segments=new ArrayList()
                for (String s : completePath.getSegments()){
                    if (s == ".."){
                        if (segments.size() > 0 && segments[segments.size()-1] != ".." ){
                            segments.remove(segments.size()-1)
                        }
                        else{
                            segments.add(s)
                        }
                    }
                    else{
                        segments.add(s)
                    }
                }
                def completeName=new RelativePath(true,segments.toArray(new String[segments.size()])).getPathString();
                if (completeName.matches(".*viewerimages/.*")) return
                result.add(completeName)
            }
          }  
    }
    return result
}
task findImages(type: DefaultTask){
    doFirst(){
            def list=fileTree("docs",{
                    include "**/*html"
            })
        def rt=findImages(list)
        rt.each { img ->
            println "image: ${img}"
        }
    }
}

task findUnusedImages(type: DefaultTask){
    doFirst(){
            def list=fileTree("docs",{
                    include "**/*html"
            })
        def rt=findImages(list)
        def images=fileTree("docs",{
                include "**/*png"
                include "**/*PNG"
                include "**/*jpg"
                include "**/*JPG"
        })
        images.visit{ FileVisitDetails element ->
            if (! element.getFile().isFile()) return;
            def path=element.getRelativePath().getPathString()
            if (path.startsWith("viewerimages")) return
            if (! rt.contains(path)){
                println "unused: $path"
            }
            else{
                println "used: $path"
            }
        }
    }
}

task upload{
    doLast {
        println "###uploaded artifacts to version dir $project.avnavVersion###"
    }
    dependsOn uploadDeb,uploadRaspi,uploadRpm,uploadViewer, uploadAccess,uploadZip
    if (onWindows){
        dependsOn uploadWindows,uploadWindowsNet
    }
    if (buildAndroid){
        dependsOn uploadAndroidBeta
    }
}

task uploadRelease{
    doLast {
        println "###upload release artifacts to version dir $project.avnavVersion###"
    }
    dependsOn testGit,uploadDeb,uploadRaspi,uploadRpm,uploadViewerRelease,uploadAccess,uploadZip
    if (onWindows){
        dependsOn uploadWindows,uploadWindowsNet,uploadAccessWindows
    }
    if (buildAndroid){
        dependsOn uploadAndroidRelease
    }
}

afterEvaluate{
    tasks.withType(org.gradle.api.tasks.GradleBuild.class){GradleBuild b->
        b.dependsOn pkgVersion
        if (project.avnavRelease) b.dependsOn testGit
        b.doFirst{
            startParameter.projectProperties.put('packageVersion',project.avnavVersion)
        }
    }
    if (project.avnavRelease) {
        tasks.withType(UploadTask.class) { UploadTask task ->
            if (! task.name.equals("uploadViewerRelease") && ! task.name.equals("uploadAccessWindows")) task.baseDir = "/www/software/avnav/downloads/release"

        }
    }
}


